// Задание связано с обратной польской нотацией. Она используется для парсинга арифметических выражений. Еще её иногда называют постфиксной нотацией.
//
// В постфиксной нотации операнды расположены перед знаками операций.
//
// Пример 1:
// 3 4 +
// означает 3 + 4 и равно 7
//
// Пример 2:
// 12 5 /
// Так как деление целочисленное, то в результате получим 2.
//
// Пример 3:
// 10 2 4 * -
//     означает 10 - 2 * 4 и равно 2
//
// Разберём последний пример подробнее:
//
//  Знак * стоит сразу после чисел 2 и 4, значит к ним нужно применить операцию, которую этот знак обозначает,
//  то есть перемножить эти два числа. В результате получим 8.
//
// После этого выражение приобретёт вид:
//
// 10 8 -
//
// Операцию «минус» нужно применить к двум идущим перед ней числам, то есть 10 и 8. В итоге получаем 2.
//
// Рассмотрим алгоритм более подробно. Для его реализации будем использовать стек.
//
//     Для вычисления значения выражения, записанного в обратной польской нотации,
//     нужно считывать выражение слева направо и придерживаться следующих шагов:
//
//     Обработка входного символа:
//     Если на вход подан операнд, он помещается на вершину стека.
//     Если на вход подан знак операции, то эта операция выполняется над требуемым количеством значений,
//     взятых из стека в порядке добавления. Результат выполненной операции помещается на вершину стека.
//     Если входной набор символов обработан не полностью, перейти к шагу 1.
//
//     После полной обработки входного набора символов результат вычисления выражения находится в вершине стека.
//     Если в стеке осталось несколько чисел, то надо вывести только верхний элемент.
//     Замечание про отрицательные числа и деление: в этой задаче под делением понимается математическое целочисленное деление.
//     Это значит, что округление всегда происходит вниз. А именно: если a / b = c, то b ⋅ c — это наибольшее число, которое не превосходит a и одновременно делится без остатка на b.
//
//     Например, -1 / 3 = -1. Будьте осторожны: в C++, Java и Go, например, деление чисел работает иначе.
//
//     В текущей задаче гарантируется, что деления на отрицательное число нет

//
// -- ПРИНЦИП РАБОТЫ --
//   Описан в условиях задачи :)
//   Используем дек, складываем в него операнды, если встречаем операцию, то идем в стек, достаем два числа и считаем их.
//   Кладем обратно в стек результат.
//  Повторяем цикл

// -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
// О(n)
//

// -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
// Как будто бы я не до конца понял, как это считать, но мы храним строку в массиве и имеем дек
// Массив фиксированной длинны, в стеке не может храниться > n
// Поэтому сложность О(n)

const _readline = require('readline');
const _reader = _readline.createInterface({
    input: process.stdin,
});
let _input = [];

_reader.addListener('line', function (line) {
    _input = line.split(' ');
})
process.stdin.on('end', solve)

const prepareData = () => _input;

class Stack {
    constructor() {
        this.items = [];
    }

    push(item) {
        this.items.push(item);
    }

    pop() {
        return this.items.pop();
    }

    peek() {
        return this.items[this.items.length - 1];
    }

    size() {
        return this.items.length;
    }
}

function solve(item) {
    const stack = new Stack();
    const polandNotation = prepareData();

    polandNotation.forEach((notationItem) => {
        if (notationItem !== "*" && notationItem !== "/" && notationItem !== "+" && notationItem !== "-") {
            stack.push(notationItem);
        } else {
            const secondOperand = Number(stack.pop());
            const operandFirst = Number(stack.pop());
            let result = 0;
            //
            // console.log(`CALCULATE: ${operandFirst} ${notationItem} ${secondOperand}`);

            if (notationItem === "*") {
                result = operandFirst * secondOperand;
            } else if (notationItem === "/") {
                result = Math.floor(operandFirst / secondOperand);
            } else if (notationItem === "+") {
                result = operandFirst + secondOperand;
            } else if (notationItem === "-") {
                result = operandFirst - secondOperand;
            }
            // console.log('CALCULATE RESULT ', result);
            stack.push(result);
        }
    });

    console.log(stack.peek());
}